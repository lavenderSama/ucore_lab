## LAB7
### 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
- 当多个进程进行互斥或同步合作时，一个进程会由于无法满足信号量设置的条件而在某一个位置停止，直到它接收到一个特定的信号。
- P操作：首先关掉中断，然后判断当前信号量的value是否大于0，如果>0，则获得信号量，故让value减1，并打开中断返回即可。如果不是>0，则将当前的进程加入到等待队列中，打开中断，让调度器选择另一个进程执行，被V唤醒之后，把自身关联的wait从等待队列中删除。
- V操作：首先关中断，如果信号量对应的等待队列中没有进程在等待，直接把信号量的value加一，然后开中断返回；如果有进程在等待且进程等待的原因是该信号量设置的，则将等待队列中等待的第一个进程唤醒，最后开中断返回。
- 用户态信号量通过系统调用，借助内核级信号量实现即可
### 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
- 内核级条件变量基于管程实现，一个管程中含有2个控制信号量和一个或多个条件信号量，通过wait_cv和signal_cv实现条件信号量的同步与互斥
- cond_wait实现：
```
monitor_t *mt = cvp->owner;
cvp->count++;
if (mt->next_count > 0)
	up(&(mt->next));
else
	up(&(mt->mutex));
down(&(cvp->sem));
cvp->count--;
```
- cond_signal实现：
```
monitor_t *mt = cvp->owner;
if (cvp->count > 0) {
 mt->next_count++;
 up(&(cvp->sem));
 down(&(mt->next));
 mt->next_count--;
}
```
- 用户级条件变量机制同样可以通过系统调用借助内核级条件变量实现